"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_fetch_1 = __importDefault(require("node-fetch"));
/**
 * A pure JavaScript Google Firebase Analytics implementation that uses
 * the HTTPS Measurement API 2 to send events to Google Analytics.
 *
 * This class provides an alternative for the Firebase Analytics module
 * shipped with the Firebase JS SDK.
 *
 * FirebaseAnalytics provides a bare-bone implementation of the new
 * HTTPS Measurement API 2 protocol (which is undocumented), with an API
 * that follows the Firebase Analytics JS SDK.
 */
class FirebaseAnalytics {
    constructor(config, options) {
        this.eventQueue = new Set();
        this.flushEventsPromise = Promise.resolve();
        this.lastTime = -1;
        this.sequenceNr = 1;
        // Verify the measurement- & client Ids
        if (!config.measurementId)
            throw new Error("No valid measurementId. Make sure to provide a valid measurementId with a G-XXXXXXXXXX format.");
        if (!options.clientId)
            throw new Error("No valid clientId. Make sure to provide a valid clientId with a UUID (v4) format.");
        // Initialize
        this.url = "https://www.google-analytics.com/g/collect";
        this.enabled = true;
        this.config = config;
        this.options = Object.assign({ customArgs: {}, maxCacheTime: 5000, strictNativeEmulation: false, origin: "firebase" }, options);
    }
    /**
     * Sends 1 or more coded-events to the back-end.
     * When only 1 event is provided, it is send inside the query URL.
     * When more than 1 event is provided, the event-data is send in
     * the body of the POST request.
     */
    send(events) {
        return __awaiter(this, void 0, void 0, function* () {
            const { config, options } = this;
            let queryArgs = Object.assign(Object.assign({}, options.customArgs), { v: 2, tid: config.measurementId, cid: options.clientId, sid: options.sessionId, _s: this.sequenceNr++, seg: 1 });
            if (options.sessionNumber)
                queryArgs.sct = options.sessionNumber;
            if (options.userLanguage)
                queryArgs.ul = options.userLanguage;
            if (options.appName)
                queryArgs.an = options.appName;
            if (options.appVersion)
                queryArgs.av = options.appVersion;
            if (options.docTitle)
                queryArgs.dt = options.docTitle;
            if (options.docLocation)
                queryArgs.dl = options.docLocation;
            if (options.screenRes)
                queryArgs.sr = options.screenRes;
            if (options.debug)
                queryArgs._dbg = 1;
            if (this.sequenceNr === 2)
                queryArgs._ss = 1; // Session start
            let body;
            const lastTime = this.lastTime;
            if (events.size > 1) {
                body = "";
                events.forEach((event) => {
                    body += encodeQueryArgs(event, this.lastTime) + "\n";
                    this.lastTime = event._et;
                });
            }
            else if (events.size === 1) {
                const event = events.values().next().value;
                this.lastTime = event._et;
                queryArgs = Object.assign(Object.assign({}, event), queryArgs);
            }
            const args = encodeQueryArgs(queryArgs, lastTime);
            const url = `${this.url}?${args}`;
            yield (0, node_fetch_1.default)(url, {
                method: "POST",
                headers: Object.assign({ "cache-control": "no-cache", "Content-Type": "text/plain;charset=UTF-8" }, (options.headers || {})),
                body,
            });
        });
    }
    addEvent(event) {
        return __awaiter(this, void 0, void 0, function* () {
            const { userId, userProperties, options } = this;
            // Extend the event with the currently set User-id
            if (userId)
                event.uid = userId;
            // Add user-properties
            if (userProperties) {
                for (const name in userProperties) {
                    event[name] = userProperties[name];
                }
                // Reset user-properties after the first event. This is what gtag.js seems
                // to do as well, although I couldn't find any docs explaining this behavior.
                this.userProperties = undefined;
            }
            // Add the event to the queue
            this.eventQueue.add(event);
            // Start debounce timer
            if (!this.flushEventsTimer) {
                this.flushEventsTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    this.flushEventsTimer = undefined;
                    try {
                        yield this.flushEventsPromise;
                    }
                    catch (_a) {
                        // no-op
                    }
                    this.flushEventsPromise = this.flushEvents();
                }), options.debug ? 10 : options.maxCacheTime);
            }
        });
    }
    flushEvents() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.eventQueue.size)
                return;
            const events = new Set(this.eventQueue);
            yield this.send(events);
            events.forEach((event) => this.eventQueue.delete(event));
        });
    }
    /**
     * Clears any queued events and cancels the flush timer.
     */
    clearEvents() {
        this.eventQueue.clear();
        if (this.flushEventsTimer) {
            clearTimeout(this.flushEventsTimer);
            this.flushEventsTimer = 0;
        }
    }
    static isValidName(name, maxLength) {
        return !!(name &&
            name.length &&
            name.length <= maxLength &&
            name.match(/^[A-Za-z][A-Za-z_\d]*$/) &&
            !name.startsWith("firebase_") &&
            !name.startsWith("google_") &&
            !name.startsWith("ga_"));
    }
    /**
     * Parses an event (as passed to logEvent) and throws an error when the
     * event-name or parameters are invalid.
     *
     * Upon success, returns the event in encoded format, ready to be send
     * through the Google Measurement API v2.
     */
    static parseEvent(options, eventName, eventParams) {
        if (!FirebaseAnalytics.isValidName(eventName, 40)) {
            throw new Error(`Invalid event-name (${eventName}) specified. Should contain 1 to 40 alphanumeric characters or underscores. The name must start with an alphabetic character.`);
        }
        const params = {
            en: eventName,
            _et: Date.now(),
            "ep.origin": options.origin,
        };
        if (eventParams) {
            for (const key in eventParams) {
                if (key === "items" && Array.isArray(eventParams[key])) {
                    eventParams[key].forEach((item, index) => {
                        const itemFields = [];
                        let customItemFieldCount = 0;
                        Object.keys(item).forEach((itemKey) => {
                            if (SHORT_EVENT_ITEM_PARAMS[itemKey]) {
                                itemFields.push(`${SHORT_EVENT_ITEM_PARAMS[itemKey]}${item[itemKey]}`);
                            }
                            else {
                                itemFields.push(`k${customItemFieldCount}${itemKey}`);
                                itemFields.push(`v${customItemFieldCount}${item[itemKey]}`);
                                customItemFieldCount++;
                            }
                        });
                        params[`pr${index + 1}`] = itemFields.join("~");
                    });
                }
                else {
                    const paramKey = SHORT_EVENT_PARAMS[key] ||
                        (typeof eventParams[key] === "number" ? `epn.${key}` : `ep.${key}`);
                    params[paramKey] = eventParams[key];
                }
            }
        }
        return params;
    }
    /**
     * Parses user-properties (as passed to setUserProperties) and throws an error when
     * one of the user properties is invalid.
     *
     * Upon success, returns the user-properties in encoded format, ready to be send
     * through the Google Measurement API v2.
     */
    static parseUserProperty(options, userPropertyName, userPropertyValue) {
        if (!FirebaseAnalytics.isValidName(userPropertyName, 24) ||
            userPropertyName === "user_id") {
            throw new Error(`Invalid user-property name (${userPropertyName}) specified. Should contain 1 to 24 alphanumeric characters or underscores. The name must start with an alphabetic character.`);
        }
        if (userPropertyValue !== undefined &&
            userPropertyValue !== null &&
            options.strictNativeEmulation &&
            (typeof userPropertyValue !== "string" || userPropertyValue.length > 36)) {
            throw new Error("Invalid user-property value specified. Value should be a string of up to 36 characters long.");
        }
        return typeof userPropertyValue === "number"
            ? `upn.${userPropertyName}`
            : `up.${userPropertyName}`;
    }
    /**
     * https://firebase.google.com/docs/reference/js/firebase.analytics.Analytics#log-event
     */
    logEvent(eventName, eventParams) {
        return __awaiter(this, void 0, void 0, function* () {
            const event = FirebaseAnalytics.parseEvent(this.options, eventName, eventParams);
            if (!this.enabled)
                return;
            if (this.options.debug) {
                console.log(`FirebaseAnalytics event: "${eventName}", params: ${JSON.stringify(eventParams, undefined, 2)}`);
            }
            return this.addEvent(event);
        });
    }
    /**
     * https://firebase.google.com/docs/reference/js/firebase.analytics.Analytics#set-analytics-collection-enabled
     */
    setAnalyticsCollectionEnabled(isEnabled) {
        return __awaiter(this, void 0, void 0, function* () {
            this.enabled = isEnabled;
        });
    }
    /**
     * Not supported, this method is a no-op
     */
    setSessionTimeoutDuration(_sessionTimeoutInterval) {
        return __awaiter(this, void 0, void 0, function* () {
            // no-op
        });
    }
    /**
     * https://firebase.google.com/docs/reference/js/firebase.analytics.Analytics#set-user-id
     */
    setUserId(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.enabled)
                return;
            this.userId = userId || undefined;
        });
    }
    /**
     * https://firebase.google.com/docs/reference/js/firebase.analytics.Analytics#set-user-properties
     */
    setUserProperties(userProperties) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.enabled)
                return;
            for (const name in userProperties) {
                const val = userProperties[name];
                const key = FirebaseAnalytics.parseUserProperty(this.options, name, val);
                if (val === null || val === undefined) {
                    if (this.userProperties) {
                        delete this.userProperties[key];
                    }
                }
                else {
                    this.userProperties = this.userProperties || {};
                    this.userProperties[key] = val;
                }
            }
        });
    }
    /**
     * Clears all analytics data for this instance.
     */
    resetAnalyticsData() {
        return __awaiter(this, void 0, void 0, function* () {
            this.clearEvents();
            this.userId = undefined;
            this.userProperties = undefined;
        });
    }
    /**
     * Enables or disabled debug mode.
     */
    setDebugModeEnabled(isEnabled) {
        return __awaiter(this, void 0, void 0, function* () {
            this.options.debug = isEnabled;
        });
    }
    /**
     * Sets a new value for the client ID.
     */
    setClientId(clientId) {
        this.options.clientId = clientId;
    }
}
function encodeQueryArgs(queryArgs, lastTime) {
    let keys = Object.keys(queryArgs);
    if (lastTime < 0) {
        keys = keys.filter((key) => key !== "_et");
    }
    return keys
        .map((key) => {
        return `${key}=${encodeURIComponent(key === "_et" ? Math.max(queryArgs[key] - lastTime, 0) : queryArgs[key])}`;
    })
        .join("&");
}
const SHORT_EVENT_PARAMS = {
    currency: "cu",
};
// https://developers.google.com/gtagjs/reference/event
const SHORT_EVENT_ITEM_PARAMS = {
    id: "id",
    name: "nm",
    brand: "br",
    category: "ca",
    coupon: "cp",
    list: "ln",
    list_name: "ln",
    list_position: "lp",
    price: "pr",
    location_id: "lo",
    quantity: "qt",
    variant: "va",
    affiliation: "af",
    discount: "ds",
};
exports.default = FirebaseAnalytics;
